### 所有权Ownership

可开辟内存(无需手动释放)，且无需Garbage Collector 保障内存安全

根据绑定的变量的生命周期的结束, 进行内存的回收

#### Stack and Heap

栈区数据必须占用已知且固定的大小 

如果栈的大小是动态且不受控制的，可能会发生栈溢出,导致程序崩溃

栈通过栈指针管理，跟踪栈顶位置，避免复杂的内存管理机制

最大限度地减少堆上重复数据的数量，清理堆上不再使用的数据确保不会耗尽空间

所有权的主要目的就是管理堆数据

#### Rule

1. 每一个值都有一个所有者
2. 值在有且只有一个所有者
3. 在所有者离开作用域，值将被丢弃

#### String类型

- 必须在运行时向内存分配器（memory allocator）请求内存。
- 需要一个当我们处理完 `String` 时将内存返回给分配器的方法。

在item生命周期结束时释放资源的模式 在C++中称为RAII - - - - 与Rust的`drop()` 函数相同

#### 变量与数据交互的方式 1.移动

```rust
let x = 5;
let y = x; // 栈的拷贝绑定

// 区分长度与容量
let s1 = String::from("Hello"); 
let s2 = s1; //制作的是引用类型
```

如果出现double free的问题?

拷贝指针、长度和容量而不拷贝数据看上去是浅拷贝 然而实际上做的是`move`操作

设计选择：Rust永远都不会创建数据的“深拷贝”，**任何自动**的复制都可被认为是对运行时性能影响较小的

#### 变量与数据交互的方式 2.克隆

```rust
let s2 = s1.clone();
```

#### 只在栈上的数据：拷贝

对于整形类型，在编译时已知大小的类型整个存储在栈上，拷贝速度快，无需进行

Drop trait 和 Copy trait不能同时存在 而**任何一组简单标量值的组合**都可以实现Copy trait.

#### 所有权与返回值与函数

向函数传递值发生了什么？移动拷贝与移动赋值 

如果需要函数使用一个值而不获得其所有权该怎么办?

比如说元组tuple or **references**引用

### 引用与借用

与指针不同，引用可以确保**指向某个特定类型的有效值**

创建的是一个指向值`s1`的引用

创建引用的行为为**借用** 

#### 可变引用

将运行时问题提前到编译期进行了处理

可变引用有一个很大的限制：**如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用**。这些尝试创建两个 `s` 的可变引用的代码会失败 **防止data race**

同时数据竞争也发生在原可变变量与可变引用之间

不能在拥有不可变引用的同时拥有可变引用  – – **读写锁分离**

编译器在作用域结束之前判断不再使用的引用的能力 — — **非词法作用域生命周期** 

#### 悬垂引用

当你拥有一些数据的引用时，编译器确保**数据不会在其引用之前**离开作用域

Dangling is not allowed.

### Slice类型

我们并没有一个真正获取 **部分** 字符串的办法

我们不得不时刻担心 `word` 的索引与 `s` 中的数据不再同步

表示集合中部分值的引用

类型为`&str` 

#### 字符串字面值就是slice

&str 为不可变引用

#### 字符串slice作为参数

如果有一个字符串 slice，可以直接传递它。如果有一个 `String`，则可以传递整个 `String` 的 slice 或对 `String` 的引用

这样可以隐式兼容`&String` 和 `&str`

### 结构体类型

#### 初始化

支持字段初始化

结构体更新语法 仍然是移动语义 **不能再使用原结构体的内容了** 与TS的更新顺序相反

结构更新语法就像带有 = 的赋值

#### 元组结构体

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
```

 `black` 和 `origin` 值的类型不同，因为它们是不同的元组结构体的实例

#### 类单元结构体

用于类中无属性，但是可以有方法

#### 结构体数据的所有权

在结构体的定义中，有意将字符串类型定义为`String`,而并不是选择切片类型

**因为我们想要结构体拥有所有的数据**

#### 结构体赋予含义

##### 通过派生trait增加实用功能

对于结构体而言，`println!`输出的格式是不明确的

`dbg!` 宏接收一个表达式的所有权（与 `println!` 宏相反，后者接收的是引用）

dbg返回的是表达式的值的所有权

debug trait — Display trait

##### 定义结构体方法(方法语法)

How to impl 高内聚?

方法的第一个参数总是self,代表调用该方法的结构体实例

Self 类型 对于面向对象很重要

方法可以与结构体中字段同名，用于设置getters和setters

###### 运算符去哪里了？

Rust拥有**自动引用和解引用**的能力

方法调用是 Rust 中少数几个拥有这种行为的地方。

##### 带有更多参数的方法

在方法签名中，可以在self后增加多个参数

#### 关联函数

区分实例方法 类方法 静态方法(**本类型**)

不是方法的关联函数经常被用作返回一个结构体新实例的构造函数

经常用于new函数的实现  `::` 语法用于关联函数和模块创建的命名空间

### 枚举与模式匹配

#### 枚举的数据成员

用于制作高效的枚举类型 

#### Option枚举及其相对于空值的优势

[有值, 无值] — 类型系统需要检查

Rust中并没有设计空值.在有空值的语言中，变量总是这两种状态之一：空值和非空值。

**Excellent Priority** 空值是一个因为某种原因目前无效或缺失的值

但在具体的实现上,设计了Option<T>

这样可以**消除错误地假设一个非空值的风险** 

#### match模式匹配

用于匹配Option<T>

如果我们在通配分支后添加其他分支，Rust 将会警告我们，因为此后的分支永远不会被匹配到。

#### if let 简洁控制流

用于处理只匹配一个模式的值而忽略其他模式的情况

### 模块系统

#### 使用包 crate 模块管理项目

crate是编译的最小代码单位 **包含二进制项 和 库**  对应**编译单元** 

 包是提供一系列功能的一个或多个crate 一个包包含一个Cargo.toml文件

包中可以包含至多一个库 crate(library crate)。包中可以包含任意多个二进制 crate(binary crate)，但是必须至少包含一个 crate（无论是库的还是二进制的）

`cargo new xxx` 用于创建包

#### 定义模块控制作用域和私有性

##### 对代码进行分组

### 常用集合

#### 使用字符串存储UTF-8编码的文本

#### 使用`push_str`和`push`附加字符串

字符保证了UTF-8编码结构

##### 使用+运算符或`format!`宏拼接字符串

```rust
fn add(self, s: &str) -> String {
```

format!宏返回一个新的带有结果内容的String

##### 理解字符串：字节、标量值和字形簇

最后一个 Rust 不允许使用索引获取 `String` 字符的原因是，索引操作预期总是需要常数时间（O(1)）。但是对于 `String` 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符

通过.chars() 或者 .bytes()

处理**单字符** **整个字符串** **局部字符串** 

`String` 实现了 `From<&str>` 这个 trait。

#### 哈希map与所有权

对于实现了Copy trait的类型,其值可以拷贝进哈希map. 

对于String这样拥有所有权的值,其值将被移动而哈希map会成为这些值的所有者.

##### 更新哈希map的不同情形

方括号形式scores【"Red"】只能用来获取值，不能用来更改值

###### 1.覆盖一个值

直接进行相同插入

###### 2.只在键没有对应值时插入键值对

如果哈希map中键已经存在则不做任何操作,如果不存在则连同值一起插入.

###### 3.根据旧值更新一个值

or_insert 以及 and_modify

### 泛型、Trait和生命周期

Option<T> Vec<T> Hashmap<K,V> Result<T,E>

trait是一个定义泛型行为的方法

当你发现代码中需要很多泛型时，这可能表明你的代码需要重构分解成更小的结构。

**泛型并不会使程序比具体类型运行得慢** 
Rust通过编译时进行泛型代码的**单态化** 将通用代码转换为特定代码 故而无运行时开销

可以使用 *trait bounds* 指定泛型是任何拥有特定行为的类型。— 类似于interfaces

在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 `Summary` trait 的类型都拥有与这个签名的定义完全一致的 `summarize` 方法。

crate 的用户可以像调用常规方法一样调用 `NewsArticle` 和 `Tweet` 实例的 trait 方法了。唯一的区别是 trait 必须和类型一起引入作用域以便使用额外的 trait 方法

实现crate有相干性coherence的限制,确保了别人的代码不会破坏自己的代码

默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。如此，trait 可以提供很多有用的功能而只需要实现指定一小部分内容

#### trait可作为参数

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

#### Trait Bound语法

trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。

通过where简化trait bound

#### 返回实现trait的类型

不过这只适用于返回单一类型的情况

Rust每一个引用都有**生命周期**

#### 避免dangling references

 Rust 确实不允许空值, 但可以声明没有初始值的变量

#### borrow checker

借用检查器

被引用的对象比它的引用者存在的时间需要更长

#### 泛型生命周期参数

生命周期注解并不改变任何引用的生命周期的长短

**只是描述了多个引用生命周期相互的关系**

```rust
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```

函数返回的引用的生命周期与函数参数所引用的值的生命周期的较小者一致

指出任何不满足这个约束条件的值都会被borrow checker拒绝

#### 深入lifetime

当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用 **没有** 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值。然而它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。

##### 结构体定义中的生命周期注解

可以在结构体中定义引用类型的数据

```RUST
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

这个注解意味着 `ImportantExcerpt` 的实例不能比其 `part` 字段中的引用存在的更久

##### 生命周期省略

更多的明确的模式被合并和添加到编译器中是完全可能的

函数或方法的参数的生命周期被称为 **输入生命周期**（*input lifetimes*），而返回值的生命周期被称为 **输出生命周期**（*output lifetimes*）

按照三条规则

##### 静态生命周期

如字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的

### 高级模式匹配

#### 使用模式的有效位置

*refutable* 与 *irrefutable* 模式的区别

不同类型的模式语法

```Rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}

```

if let 可以引入覆盖变量

```rust
let PATTERN = EXPRESSION;
```

#### 可反驳性

匹配任何传递的可能值的模式被称为是 **不可反驳的**（*irrefutable*）

函数参数 let语句 for循环只能接收不可反驳的模式

**不可反驳模式的地方不能使用可反驳模式，反之亦然** 

虽然内外符号可以被覆盖，但当内符号作用域结束之后，外符号也即不受覆盖的影响了

#### 匹配守卫

避免变量覆盖的情形 

是一个指定于 `match` 分支模式之后的额外 `if` 条件 其并不是一个模式，没有引入新的变量

#### 多个匹配

编译器会在编译时检查范围不为空，而 `char` 和数字值是 Rust 仅有的可以判断范围是否为空的类型，所以范围只允许用于数字或 `char` 值

在省略匹配中，_表示值不会绑定， _x仍然会绑定–产生移动行为

#### @绑定

使用 `@` 可以在一个模式中同时测试和保存变量值

### 自动化测试

#### 性能测试

benchmark tests

#### 文档注释测试



#### 基本属性测试

每一个测试都在一个新线程中运行.当主线程发现测试线程异常了，就将对应测试标记为失败

`assert`与`assert_eq!` 

在一些语言和测试框架中，断言两个值相等的函数的参数被称为 `expected` 和 `actual`，而且指定参数的顺序非常重要。然而在 Rust 中，它们则叫做 `left` 和 `right`，同时指定期望的值和被测试代码产生的值的顺序并不重要

`assert_eq!` 和 `assert_ne!` 宏在底层分别使用了 `==` 和 `!=`。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必须实现了 `PartialEq` 和 `Debug` trait

##### 可派生的trait

如Default Debug PartialEq

##### 添加自定义信息

作为assert宏的可选参数进行传递

##### 添加should_panic检查错误处理

可以通过expect参数查看输出内容中是否包含对应子串

##### 控制测试如何运行

默认行为是**并发运行**所有的测试，并截获测试运行过程中产生的输出

**大文件看业务，顺序访问BufReader，随机访问memmap2** 

代码重构 + 修复

### 基本类型偏执

- 使用参数值调用命令行解析逻辑，**解析过程也处理错误**
- 设置任何其他的配置
- 调用 *lib.rs* 中的 `run` 函数
- 如果 `run` 返回错误，**则处理这个错误**

1. main函数处理程序运行 lib处理真正的任务逻辑
2. 在组合配置值时, 适合使用结构体将属性值联系起来，而在复杂类型更为合适的场景下使用基本类型的反模式称为 **基本类型偏执**
3. 对于结构体实现其方法函数
4. 代码拆分
5. TDD

trait对象 —— 函数会返回实现了trait的类型，而无需指定具体返回值类型

Rust多行字符串前面的公共空白是否去除? Rust不会对之进行处理

### 检查环境变量

需要实际检查环境变量。处理环境变量的函数位于标准库的 `env` 模块中，所以我们需要在 *src/lib.rs* 的开头将这个模块引入作用域中。接着使用 `env` 模块的 `var` 方法来检查一个叫做 `IGNORE_CASE` 的环境变量，

### 将错误信息输出到标准错误 即重定向

这种区别允许用户选择将程序正常输出定向到一个文件中并仍将错误信息打印到屏幕上。

使用`eprintln!`宏

### 迭代器与闭包

#### 闭包

是可以保存在变量中或作为参数传递给其他函数的匿名函数

不同于函数，闭包允许捕获其被定义时所在作用域中的值

闭包捕获了对 `self`（即 `Inventory` 实例）的不可变引用

闭包通常不要求像 `fn` 函数那样对参数和返回值进行类型注解

==但是==

调用闭包是 `add_one_v3` 和 `add_one_v4` 能够编译的必要条件，因为类型将从其用法中推断出来

##### 捕获引用或移动所有权

闭包可以通过三种方式捕获其环境中的值，它们直接对应到函数获取参数的三种方式：不可变借用、可变借用和获取所有权

C++ 是“静态类型、弱类型”

##### 将捕获的值移出闭包

闭包体可以执行以下任一操作：将一个捕获的值移出闭包，修改捕获的值，既不移动也不修改值，或者一开始就不从环境中捕获任何值。

函数也可以实现所有的三种 `Fn` traits。如果我们要做的事情不需要从环境中捕获值，则可以在需要某种实现了 `Fn` trait 的东西时使用函数而不是闭包。

1. `FnOnce` 适用于只能被调用一次的闭包。所有闭包至少都实现了这个 trait，因为所有闭包都能被调用。一个会将捕获的值从闭包体中移出的闭包只会实现 `FnOnce` trait，而不会实现其他 `Fn` 相关的 trait，因为它只能被调用一次。
2. `FnMut` 适用于不会将捕获的值移出闭包体，但可能会修改捕获值的闭包。这类闭包可以被调用多次。
3. `Fn` 适用于既不将捕获的值移出闭包体，也不修改捕获值的闭包，同时也包括不从环境中捕获任何值的闭包。这类闭包可以被多次调用而不会改变其环境，这在会多次并发调用闭包的场景中十分重要。

#### 迭代器

lazy迭代器，创建时无操作

 `for` 循环在底层隐式地创建并接着消费了一个迭代器

##### Iterator Trait

**关联类型** associated type 与泛型相对，前者是在实现时声明Item，后者在实例化时声明类型

在迭代器中调用next方法会改变迭代器内部状态，故iter是可变的

代码consume了迭代器

==从 `next` 调用中获取的值是对 vector 中值的不可变引用。`iter` 方法生成一个不可变引用的迭代器。如果我们需要一个获取 `v1` 所有权并返回拥有所有权的迭代器，则可以调用 `into_iter` 而不是 `iter`。类似地，如果我们希望迭代可变引用，可以调用 `iter_mut` 而不是 `iter`。==

##### 消费迭代器

如sum函数，在获取迭代器所有权之后，反复调用next来遍历迭代器

*consuming adaptors*

##### 产生迭代器

*iterator adaptors*

所有的迭代器都是惰性的，你必须调用一个消费适配器方法

### 智能指针

#### 使用场景

String和Vec<T>都属于智能指针

智能指针通常使用结构体实现

- 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
- 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
- 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候

#### 使用Box<T>在堆上储存数据

Box本身在栈中 用于指向堆上的数据

##### 可用于创建递归类型

递归类型的值嵌套理论上可以无限地进行下去，所以 Rust 不知道递归类型需要多少空间。

而因为 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。

`cons list` 

```rust
enum List {
    Cons(i32, List),
    Nil,
}

```

######  Rust 如何决定需要多少空间来存放一个非递归类型

对于一个枚举类型，所需的空间等于储存其最大成员的空间大小。

##### Box Trait实现

box 只提供了间接存储和堆分配

`Box` 类型是一个智能指针，因为它实现了 `Deref` trait，它允许 `Box` 值被当作引用对待。当 `Box` 值离开作用域时，由于 `Box` 类型 `Drop` trait 的实现，**box 所指向的堆数据也会被清除** — 智能型。

#### 通过 `Deref` trait 将智能指针当作常规引用处理

为何解引用运算符不能像引用一样工作？

##### 自定义智能指针

Box在堆上作为实例而存在

本质上作为泛型的元组结构体而存在 通过`new`方法进行创建 在作用域后自动卸载

`?Sized`进行DST动态大小类型标记

`&self` 实际上是 `self: &Self` 的缩写

为何Deref需要返回对应值的引用？避免move

**实际的底层操作** `*(y.deref())`

Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 `Deref` 的类型。

##### 函数和方法的Deref隐式强制转换

当所涉及到的类型定义了 `Deref` trait，Rust 会分析这些类型并使用任意多次 `Deref::deref` 调用以获得匹配参数的类型

不断调用Deref，直到参数匹配成功或报错

进行编译的静态绑定

##### 注意

Rust 的类型注释（type annotations）在表达式中并不是直接支持的

只在变量声明 函数声明时进行

表达式作为动态，并不能被编译器静态分析类型

#### 通过Drop trait运行清理代码

局部变量以被创建时相反的顺序被丢弃

std::mem::drop() 进行的是 移动所有权

结构体中如果有需要drop的成员，不需要显式地定义结构体上层自身的drop函数, 上层的drop只是用于本身的实现

#### Rc<T> 引用计数智能指针

`Rc` 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。

Rc**只用于单线程** 

`Rc::clone` 的实现并不像大部分类型的 `clone` 实现那样对所有数据进行深拷贝。`Rc::clone` 只会增加引用计数

strong and weak pointer

只有当弱引用为0时，Rc才会释放内存 分为析构函数和释放内存两步

如果不使用这种办法，多线程环境下可能出现控制块（即记录引用计数等内容的内存）重删或漏删的情况

你不能通过共享指针直接修改其指向的数据

#### RefCell<T> 和 内部可变性模式

对于 `RefCell`，不可变性作用于 **运行时**。

即裸指针的实际实现

由于静态分析是保守的 如果 Rust 编译器不能通过所有权规则编译，它可能会拒绝一个正确的程序

- `Rc` 允许相同数据有多个所有者；`Box` 和 `RefCell` 有单一所有者。
- `Box` 允许在编译时执行不可变或可变借用检查；`Rc`仅允许在编译时执行不可变借用检查；`RefCell` 允许在运行时执行不可变或可变借用检查。
- 因为 `RefCell` 允许在运行时执行可变借用检查，所以我们可以在即便 `RefCell` 自身是不可变的情况下修改其内部的值。

通过`RefCell`的内部可变性 指向可变引用实现在不改动trait的签名的前提下实现修改功能

#### 引用循环和内存泄漏

通过将Rc<T>转变为Weak<T> 避免引用循环

